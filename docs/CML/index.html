<!DOCTYPE html>
<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />


  <title>CML（Context Mark Language）</title>

  <style type="text/css">
    /*
    页面背景色、正文文字主色、线条颜色、代码块背景色
    */
    :root {
      --color-bg: #282c34;          
      --color-text: #fff;       
      --color-line:#544c48;   
      --color-code-bg: #f6f8fa33;  
    }
    /* :root {
      --color-bg: #fff;          
      --color-text: #000;       
      --color-line:#ddd;   
      --color-code-bg: #b6b8ba33;  
    } */

    body {
      padding: 5vh 20vw;
      color: var(--color-text);
      background-color: var(--color-bg);
    }
    .topnav{
      display: flex;
      justify-content: space-between;
    }
    h1{
      font-size:48px;
    }
    h2{
      font-size:36px;
    }
    h3{
      font-size:24px;
      color:#ff8822;
    }
    h4{
      color:#a2e8ff;
    }


    img{
      max-width: 100%; /* 图片最大宽度不超过容器 */
      height: auto;    /* 高度自动按比例缩放 */
    }
    a {
      color: var(--color-text);
    }
    code {
      background-color: var(--color-code-bg);
      padding: 0.2em 0.4em;
      border-radius: 4px;
      font-family: Consolas, Monaco, 'Courier New', monospace;
      font-size: 90%;
    }
    pre {
      background-color: var(--color-code-bg);
      padding: 1em;
      border-radius: 6px;
      overflow: auto;
      font-size: 14px;
      line-height: 1.5;
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    pre code {
      background: none;
      font-size: 100%;
      padding: 0;
      border-radius: 0;
      font-family: Consolas, Monaco, 'Courier New', monospace;
    }
    pre code code{
      background: none;
      font-size: 100%;
      padding: 0;
      border-radius: 0;
      font-family: Consolas, Monaco, 'Courier New', monospace;
    }
  </style>
  <style>
    .language-menu {
      display: inline-block;
      position: relative;
      font-size: 14px;
    }
    .current-language {
      cursor: pointer;
      user-select: none;
    }
    .language-popup {
      display: none;
      position: absolute;
      top: 100%;
      left: 0;
      background: var(--color-text);
      color:var(--color-bg);
      padding: 4px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      white-space: nowrap;
      z-index: 100;
    }
    .language-line{
      margin:10px;
    }
    .language-popup a {
      display: block;
      color: #000;
      text-decoration: none;
      margin: 2px 0;
    }
    .language-popup a:hover {
      text-decoration: underline;
    } 
  </style>
  <style>
    .logo {
      border: 3px solid #fff;
      border-radius: 150px;
      padding: 4px;
      width: 150px;
      height: 150px
    }
    .line{
      display: flex;
      align-items: center;
      gap: 4px;
    }
    .icon{
      width: 28px;
      height: 28px;
    }
    .red{
      color:red;
    }
    .sup{
      font-size:13px;
      color:white;
    }
    .blue{
      color:blue;
    }
    .green{
      color:green;
    }
    #tabs {
      display: flex;
      list-style: none;
      padding: 0;
      border-bottom: 1px solid var(--color-line);
      align-items: center; 
      margin-top:30px;
    }
    #tabs li {
      padding: 10px 20px;
      cursor: pointer;
      font-size:24px;
      border-bottom: none;
      margin-right: 5px;

    }
    #tabs li.active {
      font-weight: bold;
      font-size:24px;
      background-color: var(--color-code-bg);
    }
    .tab-pane {
      display: none;
      padding: 20px;
      min-height: 300px;
      width:100%;
      min-width: 100%;
    }
    .tab-pane.active {
      display: block;
    }
    .gray-table {
      width: 100%;
      border-collapse: collapse;
      border: 1px solid #ccc;
    }
    .gray-table th,
    .gray-table td {
      border: 1px solid #ccc;
      padding: 6px 8px;
      text-align: left;
    }

  </style>
</head>

<body>
  <div id="app">
    <div class="topnav">
      <div class="language-menu">
        <div class="current-language">简体中文 ▾</div>
        <div class="language-popup" style="display: none;">
          <div class="language-line"><a href="../contextmarklanguage">English</a></div>
          <!-- 如果当前是中文页面，也可反向加一行跳英文 -->
          <div class="language-line">简体中文 <span style="color:#999;">(当前)</span></div>
        </div>
      </div>
      <div class="line">
        <span>
          <a href="https://github.com/ContextMark/CML" target="_blank" style="display: inline-flex; align-items: center; gap: 0.4em;">
            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="currentColor" viewBox="0 0 16 16">
              <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 
              2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 
              0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52
              -.01-.53.63-.01 1.08.58 1.23.82.72 1.21 
              1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78
              -.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15
              -.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82a7.6
              7.6 0 0 1 2-.27c.68 0 1.36.09 2 .27 1.53-1.04 
              2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56 
              .82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 
              3.95.29.25.54.73.54 1.48 0 1.07-.01 
              1.93-.01 2.2 0 .21.15.46.55.38A8.013 
              8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"/>
            </svg>
          </a>
        </span>
        <span>
          <a href="https://doc-war.com" target="_blank" style="display: inline-flex; align-items: center; gap: 0.4em;">
            <img src="../img/logo.png" class="icon">
          </a>
        </span>
      </div>
    </div>
    <div  class="content">
      <section >
        <h1>CML</h1>
        <p>Context Mark Language（简称CML），面向AI时代的上下文标记需要，提供符合自然语义的全新标记架构。</p>
        <p>Context Mark Language标记语法的核心特征，是用单字符串表示多维度、可组合、隐含上下文关系的语义性标记结构，提供更简单的编写、嵌入、传输、存储、运算体验。</p>
        <p>最新版本: 1.0.0-beta.1</p>
        <h2>论文</h2>
        <p>CML阐释了Context Structure Expression模型。论文详见：</p>
        <ul>
          <li>
            <a href="https://doi.org/10.5281/zenodo.15255534">DOI 10.5281/zenodo.15255534.</a>
          </li>
          <li>
            英文版本：<a href="https://github.com/ContextMark/CML/blob/main/paper/CSE.md">CSE:A Unified Modeling Framework for Semantic Contextual Markup</a>
          </li>
          <li>
            中文版本：<a href="https://github.com/ContextMark/CML/blob/main/paper/CSE_zh.md">CSE模型：上下文语义标记的统一建模框架</a>
          </li>
        </ul>
      </section >
      <ul id="tabs">
        <li class="active" data-tab="tab1">语义架构</li>
        <li data-tab="tab2">语义结构</li>
        <li data-tab="tab3">标记格式</li>
        <li data-tab="tab4">编码规则</li>
        <li data-tab="tab5">最小完备性</li>
      </ul>
      <!-- <h2>一、语义架构</h2> -->
      <section id="tab1" class="tab-pane active">
        <p>Context Mark Language能极简的表达语义化的上下文结构。</p>
        <p>用于标记知识上下文的CML字符串，是由一系列的<code>语义Token</code>+<code>关系分割符</code>两个<code>语义基元</code>类型构成。</p>
        <ul>
          <li><strong>语义Token</strong>，是CML描述上下文语义的基本单位，可以是任意形式的文本片段，对应LLM领域的Token概念，但不是词法性的，而是承载了自然语义的抽象维度。</li>
          <li><strong>关系分隔符</strong>（<code>:</code>、<code>.</code>、<code>@</code>、<code>+</code>、<code>空格</code>）用于表达这些语义Token之间的上下文结构关系的语义，隐式声明加权分配的优先级。</li>
        </ul>
        <p>在语义基元自由组合的基础上，进行编码，就构成了最终的CML字符串</p>
        <img src="./assets/image-20250409231615178.png" alt="编码格式图示">
        <h3>表达规则</h3>
        <p>CML采用线性结构来描述语义关系（易于嵌入）。</p>
        <p>假设我们用 <code>&lt;semantic_token&gt;</code> 来表示语义Token，<code>&lt;separator&gt;</code> 来表示关系分隔符。那么，规则大致可以这样定义：</p>
        <ol>
          <li>每个 <strong>语义Token</strong>（<code>&lt;semantic_token&gt;</code>）必须通过有且只有一个 <strong>关系分隔符</strong>（<code>&lt;separator&gt;</code>）相互连接。</li>
          <li>语义Token和关系分隔符总是交替出现，<code>&lt;semantic_token&gt;&lt;separator&gt;&lt;semantic_token&gt;&lt;separator&gt;......&lt;semantic_token&gt;</code>。</li>
        </ol>
      </section>
      <!-- <h2>二、语义结构</h2> -->
      <section id="tab2" class="tab-pane">
        <p>CML围绕Token的<strong>优先级表达</strong>、<strong>结构可扩展</strong>、<strong>逻辑可正交</strong>三个核心需求维度，抽象出的具有高度表达力与组合力的5个语义结构基元，作为构建一切逻辑语义关系的基础单位。</p>
        <p>这5种结构基元，分<code>基本结构</code>和<code>复合结构</code>、<code>组合结构</code>三大类，基本结构描述多个基元语义Token之间的简单结构关系，同时可作为复合结构的组成单元，而组合结构是更宏观的容器类型，可以连接任意语义Token、基本结构和复合结构。</p>
      
        <h3>a、补充关系<sup class="sup">（基本结构）</sup></h3>
        <p>右边语义对象对左边语义对象的补充说明或解释、限制，通常是语义附加，不改变原语义结构</p>
        <pre><code>f:A∋B∋C</code></pre>
        <p>以符号@来表达，越靠左优先级越高，表示权重应该更高。</p>
        <p>比如</p>
        <ul>
          <li><code>name</code>@<code>identity</code>@<code>organization</code></li>
          <li><code>name</code>@<code>company</code>@<code>position</code></li>
        </ul>
        <p>两组标记的权重优先级声明是不同的，都重点都是先强调姓名。</p>
      
        <h3>b、线性递进关系<sup class="sup">（基本结构）</sup></h3>
        <p>一种有序的、逐步推进的语义关系，可以表达各种带方向的轨迹：递进、流向、变换链、指向链、顺序、因果、类型细化、生命周期......</p>
        <pre><code>f:A→B→C</code></pre>
        <p>用符号<code>.</code>表达，左侧权重是否应该略高于右侧，需要LLM可以结合实际语义token来最终判断权重优先级。</p>
        <p>比如</p>
        <ul>
          <li><code>生物</code>.<code>动物</code>.<code>人</code>，重点落在<code>人</code>这个子类上。</li>
          <li><code>产品设计</code>.<code>开发</code>.<code>运营</code>，结合语义token本身，可以很清楚的判定他描述了一个生命周期语义。</li>
        </ul>
      
        <h3>c、并列集合关系<sup class="sup">（基本结构）</sup></h3>
        <p>多个语义并列，类似集合、对象属性集、多分支描述，无优先级或顺序，可以互调位置。</p>
        <pre><code>f:{A, B, C}</code></pre>
        <p>用符号<code>+</code>表达，权重不分主次先后。</p>
        <p>比如</p>
        <ul>
          <li><code>男人</code>+<code>女人</code>，相对<code>人</code>这个概念，正反组合都一样。</li>
          <li><code>姓名</code>+<code>年龄</code>+<code>username</code>，都是某个账号的注册信息。</li>
        </ul>
      
        <h3>d、映射关系<sup class="sup">（复合结构）</sup></h3>
        <p>一种语义结构到另一种语义结构的复合对照，k-v形式，两边都可以使用3种基本关系的自由组合，用于支持二维语义表达</p>
        <pre><code>f(A,B) ↦ f(C,D,E)</code></pre>
        <p>用符号<code>:</code>表示。类似于键值对，但构造更自由，无论是key还是value部分，都可以使用基本结构，而不仅仅是基元语义token。</p>
        <pre><code>&lt;key-context-struct&gt;:&lt;value-context-struct&gt;</code></pre>
        <p>比如下面都是合法的映射语义结构</p>
        <ul>
          <li><code>网站</code>:<code>doc-war.com</code></li>
          <li><code>网站</code>@<code>doc-war.com</code>:<code>文档战场</code>@<code>贡献判断力价值</code></li>
          <li><code>AI</code>+<code>LLM</code>:<code>ChatGPT</code>+<code>Claude</code>@<code>v3.7</code></li>
          <li><code>ask</code>.<code>answer</code>: <code>请介绍CML语言?</code>.<code>CML语言是符合自然语义的语义结构语言</code></li>
        </ul>
      
        <h4>特别约束</h4>
        <p>CML<strong>不支持嵌套映射</strong>，避免带来语义结构本身的解析复杂度。比如<code>用户:张三:删除+查询</code>之类的表达，在格式上是非法的。</p>
      
        <h3>e、组合关系<sup class="sup">（组合结构）</sup></h3>
        <p>多个语义结构组合形成新的语义整体，而不损失其原语义，反之拆分亦然，本质上是一种可运算的“关系结构容器”。</p>
        <pre><code>
      f(A)+f(B) =f(A+B)
      f(A) =f(A+B) - f(B)
      </code></pre>
        <p>用<code>空格</code>表示对任意两个结构的语义叠加。</p>
        <p>由于<code>空格</code>的语义优先级最低，且左右顺序无优先级影响，他同时也是CML字符串的整体运算符，对明文格式的两个CML字符串使用空格自然拼接成一个新的CML字符串，仍然是一个合法的CML字符串，不影响原语义表达。</p>
        <pre><code>plaintext(A)+space+plaintext(B) = plaintext(A+space+B)</code></pre>
        <p>这种可自由拆分—&gt;还原的<strong>无损还原</strong>特征，让CML字符串具备语义运算特征，而不仅仅是语义表达，为标记工作分工协同提供了坚实基础。</p>
      
        <h4>特别约束</h4>
        <p>由于<code>空格</code>承担了语义上的无损运算职责，比如<code>如果 用户:张三怎么样</code>之类的用法，虽然在格式上是合法的，但一定会破坏无损组合原则，当多个语义字符串被拆分重组之后，会因为位置不同而颠覆原有语义。</p>
      
        <h3>运算优先级</h3>
        <p>关系运算类似于编程语言的表达式解析：从左往右进行词法扫描，然后根据关系分割符的优先级，决定语义运算顺序。</p>
        <p>CML定义了明确的优先级，以确保在标记、推理阶段对语义解释的一致性。</p>
        <pre><code>补充关系<sup>a</sup> &gt; 线性递进关系<sup>b</sup> &gt; 并列集合关系<sup>c</sup> &gt; 映射关系<sup>d</sup> &gt; 组合关系<sup>e</sup></code></pre>
      </section>
      <!-- <h2>三、CML格式</h2> -->
      <section id="tab3" class="tab-pane"> 
        <p>在语义表达的基础上，定义了2种标准的CML字符串标记模式。核心区别是，在什么阶段，用什么形式，来标记语义Token（semantic_token）本身。</p> <img
          src="./assets/image-20250402230135032.png" alt="CML格式示意图">
        <h3>自然语言格式</h3>
        <p>自然语言格式，面向文档工程师的<code>明文编写</code>体验，适用于人类可读场景。</p>
        <p>以markdown语法中的反引号标记（inline code），来包裹语义Token（semantic_token）。文档工程师，可以使用所见即所得的markdown编辑器，作为语义结构的明文编辑环境，可以非常快捷、直观。</p>
        <p>比如，用markdown编写明文字符串：</p>
        <pre><code>`token1`.`token2`@`token3`+`token4` `token5`:`token6` </code></pre>
        <p>自动实时渲染成下面的自然语义效果，一目了然：</p>
        <p><code>token1</code>.<code>token2</code>@<code>token3</code>+<code>token4</code>
          <code>token5</code>:<code>token6</code></p>
        <h4>换行问题</h4>
        <p>在自然编辑中，从可读性角度，人类倾向于对长字符串进行换行分割，而不是坚持使用空格来分割。因此，CML编辑器应该支持符号等价兼容，在明文解析和存储时，将
          <code>\n</code>、<code>\r\n</code>、<code>\r</code> 等各种换行符号，自动改成 <code>空格</code>。</p>
        <h4>内嵌反引号问题</h4>
        <p>由于反引号没有转义表示，明文格式遵循Markdown生态的事实性标准方案：对于内部带有反引号的Token，用更多的反引号来包裹Token。如标记 <code>console.log(`hello,${name}`)</code>
          需要用下面的方式来实现。</p>
        <pre><code>```console.log(`hello,${name}`)```</code></pre>
        <h3>编码格式</h3>
        <p>带反引号<code>`</code>的CML字符串，包括+号、空格，在某些特殊场景下，可能会带来偏离预期的解析边界和转义要求。而其他分隔符和内部的Token值，也可能在URL、文件、key、变量命名场景具有不安全性。</p>
        <p>比如：</p>
        <ul>
          <li>在模版字符串中使用反引号</li>
          <li>在URL、正则中使用+号、空格</li>
          <li>在sql语句、shell脚本中使用反引号</li>
          <li>和html或其他格式的嵌套，尤其是semantic_token文本原文本身也含有反引号自身时</li>
          <li>......</li>
        </ul>
        <p>因此，面向<code>嵌入</code>、<code>存储</code>、<code>解析</code>、<code>运算</code>、<code>命名</code>场景，CML定义了更安全一致的编码输出格式。</p>
      </section>
      <!-- <h2>四、编码规则</h2> -->
      <section id="tab4" class="tab-pane"> 
        <p>CML提供多种模式的编码方案可选，以增强在<code>短语义场景</code>、<code>大规模语义场景</code>和<code>传输限制场景</code>的适应性。</p>
        <h3>编码模式</h3>
        <p>
          一个编码格式的CML字符串，无论何种编码，均由两部组成：<code>&lt;rule_token&gt;&lt;semantic_payload&gt;</code>。由<strong>首位</strong>负责表达规则版本，映射协议及更具体的编码模式。
        </p>
        <h4>规则标识</h4>
        <p>标准规则集所对应的规则标识符，仅限于<code>a-z</code>26个小写字母，即预留了26种组合位置，大写作为极端保留范围冻结，正常不会启用。未来100%不会使用数字和其他特殊字符来做标识符，以确保天然可以安全用于key、变量场景。</p>
        <p>当前只定义了4种标准规则。</p>
        <table class="gray-table">
          <thead>
            <tr>
              <th>标识</th>
              <th>协议版本</th>
              <th>编码规则</th>
              <th>场景</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>a</td>
              <td>1.0</td>
              <td>双层Base58编码</td>
              <td>不包含任何特殊符号，在短语义场景具有完美的适应性</td>
            </tr>
            <tr>
              <td>c</td>
              <td>1.0</td>
              <td>双层Base64URL编码，无<code>=</code>号。</td>
              <td>提供最大的编解码性能，大规模语义场景</td>
            </tr>
            <tr>
              <td>q</td>
              <td>1.0</td>
              <td>明文混编编码模式，对混编的语义荷载进行一次整体的Base64URL编码，无<code>=</code>号。</td>
              <td>在兼顾不可读的基础上，追求最小熵增</td>
            </tr>
            <tr>
              <td>p</td>
              <td>1.0</td>
              <td>明文混编模式，单层架构，不再整体编码。</td>
              <td>最小熵增，最大的信息容量，面向二维码、短信场景</td>
            </tr>
          </tbody>
        </table>
        <h4>助记说明</h4>
        <ul>
          <li>c对应cpu缩写，追求cpu友好；</li>
          <li>q对应qrcode缩写，取意面向二维码场景；</li>
          <li>p是plaintext的缩写，取意明文；</li>
          <li>a则留给了Base58，因为这是最早设计的模式，具有最高的安全普适性。</li>
        </ul>
        <h3>a模式</h3>
        <p>a模式，指1.0标记协议+双层Base58编码规则。</p>
        <h4>示例</h4>
        <p>以下是a模式的编码示例。</p>
        <pre><code>`token1`.`token2`@`token3`+`token4` `token5`:`token6`</code></pre>
        <p>将以上明文CML字符串按如下顺序编码：</p>
        <ol>
          <li>从CML字符串原文中顺序提取<code>语义Token</code>和<code>关系分隔符</code></li>
          <li>先将每一个语义Token原文（不包括反引号的token字符串），使用UTF-8编码成字节流，再对字节流进行Base58编码，生成Base58字符串</li>
          <li>再用关系分隔符原文重新拼接</li>
        </ol>
        <pre><code>zyvFCwFv.zyvFCwFw@zyvFCwFx+zyvFCwFy zyvFCwFz:zyvFCwG1</code></pre>
        <ol start="4">
          <li>再次用UTF-8+Base58进行整体编码，消除一切特殊字符，拿到整体语义荷载</li>
        </ol>
        <pre><code>3EkzyE8r5SqnU6KSbLS98LVLJxFoNvskzaazkuEEryWminqaGwJz13YoatvfoRWoDyrofwUCQ</code></pre>
        <ol start="5">
          <li>最后，拼接首位模式标识符<code>a</code>，构成最终的CML编码字符串</li>
        </ol>
        <pre><code>a3EkzyE8r5SqnU6KSbLS98LVLJxFoNvskzaazkuEEryWminqaGwJz13YoatvfoRWoDyrofwUCQ</code></pre>
        <p>解码环节基于首位进行模式路由，反向还原到原始明文格式。</p>
        <h3>c模式</h3>
        <p>c模式，指1.0标记协议+双层Base64URL编码规则。</p>
        <p>与双层Base58编码的流程完全一致，只是将编码方式改成Base64URL，将原来O(n²log n)的编解码复杂度降低到O(n)。</p>
        <table class="gray-table">
          <thead>
            <tr>
              <th>编码方式</th>
              <th>输入长度</th>
              <th>输出长度</th>
              <th>理论CPU指令</th>
              <th>估计耗时</th>
              <th>主要瓶颈</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Base64</td>
              <td>100KB</td>
              <td>133.3KB</td>
              <td>~200K条</td>
              <td><strong>0.1-0.5ms</strong></td>
              <td>位运算+查表</td>
            </tr>
            <tr>
              <td>Base58</td>
              <td>100KB</td>
              <td>138KB</td>
              <td>~50M条</td>
              <td><strong>50-200ms</strong></td>
              <td>大数除法运算</td>
            </tr>
          </tbody>
        </table>
        <h3>q模式</h3>
        <p>q模式，指1.0标记协议+明文混编编码模式。</p>
        <p>
          <code>q模式</code>依然遵循双层编码架构，但最大限度的减少不必要的双层编码，相比<code>a模式</code>、<code>c模式</code>，核心差异在于对token层是否编码采取动态、自动处理规则，而不是一刀切：
        </p>
        <ul>
          <li>语义荷载内部支持<code>&lt;plaintextToken&gt;&lt;separator&gt;&lt;encodedToken&gt;</code>混编</li>
          <li>明文优先，对于混编进来的<code>&lt;encodedToken&gt;</code>，使用编码标识符<code>!</code>进行尾部修饰，告诉解码器这不是明文，需要进一步解码。</li>
          <li>
            如果一个Token内部包含任何cml分隔符（<code>@</code>、<code>.</code>、<code>+</code>、<code>:</code>、<code>空格</code>）和编码标识<code>!</code>6种字符，将被强制编码。
          </li>
          <li>无论是Token层编码，还是外围的整体编码，均采用base64URL。</li>
        </ul>
        <h4>示例</h4>
        <p>对于原始的CML关系语义：<code>`这是明文`@`这要编码！`</code>，明文字符串如下：</p>
        <pre><code>`这是明文`@`这要编码！`</code></pre>
        <p>如果采用<code>c模式</code>编码，则在整体编码前，拼接出来的语义荷载是这样：</p>
        <pre><code>6L-Z5piv5piO5paH@6L-Z6KaB57yW56CB77yB</code></pre>
        <p>而采用<code>q模式</code>编码，则拼接出来的语义荷载是这样：</p>
        <pre><code>这是明文@6L-Z6KaB57yW56CB77yB!</code></pre>
        <p>再整体编码：</p>
        <pre><code>6L-Z5piv5piO5paHQDZMLVo2S2FCNTd5VzU2Q0I3N3lCIQ</code></pre>
        <p>最后前缀附加模式标识q，构成最终的CML编码格式字符串：</p>
        <pre><code>q6L-Z5piv5piO5paHQDZMLVo2S2FCNTd5VzU2Q0I3N3lCIQ</code></pre>
        <h3>p模式</h3>
        <p>p模式，指1.0标记协议+不二次编码的明文混编模式。</p>
        <p><code>p模式</code>，是<code>q模式</code>的简化版本，剔除了双层编码架构，以最大限度的减熵。</p>
        <h4>同一个示例</h4>
        <p>对于原始的CML关系语义：<code>`这是明文`@`这要编码！`</code></p>
        <p>明文字符串如下：</p>
        <pre><code>`这是明文`@`这要编码！`</code></pre>
        <p>无论采用p模式还是q模式，编码后拼接出来的语义荷载都是这样：</p>
        <pre><code>这是明文@6L-Z6KaB57yW56CB77yB!</code></pre>
        <p>但p模式不再对语义荷载整体编码，而是直接附加前缀，构成最终的CML编码格式字符串：</p>
        <pre><code>p这是明文@6L-Z6KaB57yW56CB77yB!</code></pre>
      </section>
      <!-- <h2>四、最小完备性</h2> -->
      <section id="tab5" class="tab-pane">
        <p>五种关系分隔符，源自对自然语言的语义表达结构的抽象提炼，亦是对表达歧义与结构可控性问题的深入思考。</p>
        <h3>自然语言参考</h3>
        <p>CML定义的5种关系分隔符，参考的是自然语言中隐含的最基本的语义结构（<strong>修饰</strong>、<strong>顺承</strong>、<strong>并列</strong>、<strong>对照</strong>、<strong>组合</strong>）。这五种语义结构，与中英法日等具体自然语言的语法表达风格无关。</p>
        <pre><code>
      自然语言示例：
      例子: 那个<code>戴着帽子</code><sup>C</sup> 的<code>高个子</code><sup>B</sup><code>男人</code><sup>C</sup>               (A←B←C)
      例子: 他<code>起床</code><sup>A</sup>，<code>穿衣服</code><sup>B</sup>，<code>出门</code><sup>C</sup>                    (A→B→C)
      例子: 我喜欢<code>苹果</code><sup>A</sup>, <code>香蕉</code><sup>B</sup>, <code>橙子</code><sup>C</sup>                  {A，B，C}
      例子: <code>ChatGPT</code><sup>A</sup>和<code>Claude</code><sup>B</sup>、<code>DeepSeek</code><sup>C</sup> 都是 <code>AI</code><sup>D</sup>，也叫<code>LLM</code><sup>E</sup>   (A+B+C ↦ D+E)
      例子: <code>这朵花</code><sup>A</sup> + <code>很美</code><sup>B</sup> = <code>这朵花很美</code><sup>A+B</sup>             (A+B=AB)
      </code></pre>
        <p>理论上，借助这5种基元关系的组合，能表达绝大部分逻辑关系，具有相当的完备性。</p>
      
        <h3>Token内部语义</h3>
        <p>对于排除、量词区间、映射嵌套等逻辑关系，CML不做原生支持，下沉至Token 层，来配合<strong>补充关系</strong>进行灵活表达，避免结构污染，带来优先级运算和人类直观阅读的复杂度。</p>
        <p>因为Token本身也可以表达结构。</p>
        <pre><code>
      自然语言例子: “他的<code>年龄</code>大约<code>18~25岁</code>，一定<code>不是中国人</code>。”
      标记:
      ❌ `age`:`range`:`18-25`        （非法嵌套且毫无必要，完全可以往前或往后合并）
      ❌ `age`:`&gt;18`+`&lt;25`            （没必要拆这么细）
      ✅ `age`:`range:18-25`         （在Token内部嵌套是符合自然语义的）
      ✅ `age`:`18-25`      
      </code></pre>
      
        <p>这体现了结构的<strong>极简原则</strong>：</p>
        <p>CSE范式并不试图预先显式解决一切结构语义上的歧义，而是在实际表达时，借助关系分隔符所连接的语义Token，作为关系语义的上下文，让LLM推理出最合理的语义关系和对应的权重优先级。</p>
      
        <h3>显式结构的核心价值</h3>
        <p>主张善用Token内部的语义结构表达，也反映了CML在显式编码上的核心价值。</p>
        <p>CML之所以接近于自然语言，而不等于纯自然语言，除了用于声明重要语义，还有其表达上的必要性。相比自然语言推理在token切分上的完全不可控，显式分割的本质，是进行语义纵向层级和横向关系的拆分，进而消除关系歧义，最终提升可控性与可解释性。</p>
      </section>
    </div>
  </div>

  <script>
    const tabs = document.querySelectorAll('#tabs li');
    const panes = document.querySelectorAll('.tab-pane');

    tabs.forEach(tab => {
      tab.addEventListener('click', () => {
        tabs.forEach(t => t.classList.remove('active'));
        panes.forEach(p => p.classList.remove('active'));
        tab.classList.add('active');
        document.getElementById(tab.dataset.tab).classList.add('active');
      });
    });
    //跨页面处理语言跳转
    const current = document.querySelector('.current-language');
    const popup = document.querySelector('.language-popup');
  
    current.addEventListener('click', () => {
      popup.style.display = popup.style.display === 'none' ? 'block' : 'none';
    });
  
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.language-menu')) {
        popup.style.display = 'none';
      }
    });
  </script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script>
</body>
</html>